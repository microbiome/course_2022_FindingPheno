[["index.html", "Introduction to multi-omics data analysis Chapter 1 Overview 1.1 Introduction 1.2 Learning goals [TO DO] 1.3 Acknowledgments", " Introduction to multi-omics data analysis University of Turku 2022-01-08 Chapter 1 Overview Welcome to the multi-omics data analysis workshop Figure source: Moreno-Indias et al. (2021) Statistical and Machine Learning Techniques in Human Microbiome Studies: Contemporary Challenges and Solutions. Frontiers in Microbiology 12:11. 1.1 Introduction This course is based on miaverse (mia = MIcrobiome Analysis) is an R/Bioconductor framework for microbiome data science. It extends another popular framework, phyloseq. The miaverse consists of an efficient data structure, an associated package ecosystem, demonstration data sets, and open documentation. These are explained in more detail in the online book Orchestrating Microbiome Analysis. This workshop material walks you through example workflows for multi-omics data analysis covering data access, exploration, analysis, visualization and reproducible reporting. You can run the workflow by simply copy-pasting the examples. For advanced material, you can test and modify further examples from the OMA book, or try to apply the techniques to your own data. 1.2 Learning goals [TO DO] This workshop provides an overview of bioinformatics tools for multi-omics studies, ranging from data preprocessing to statistical analysis and reproducible reporting. Target audience Advanced students and applied researchers who wish to develop their skills in microbial community analysis. [TO DO] Venue [TO DO] 1.3 Acknowledgments Citation “Introduction to microbiome data science (2021). URL: https://microbiome.github.io.” Borman et al. (2022) We thank Felix Ernst, Sudarshan Shetty, and other miaverse developers who have contributed open resources that supported the development of the training material. Contact Leo Lahti, University of Turku, Finland License All material is released under the open CC BY-NC-SA 3.0 License. Source code The source code of this repository is fully reproducible and contains the Rmd files with executable code. All files can be rendered at one go by running the file main.R. You can check the file for details on how to clone the repository and convert it into a gitbook, although this is not necessary for the training. Landing page (html): workshop teaching material Source code (github): workshop teaching material References "],["program.html", "Chapter 2 Program 2.1 Day 1 2.2 Day 2", " Chapter 2 Program The workshop takes place on the 13th and 14th of January from 11am – 6pm (EET). Short breaks will be scheduled between sessions. The practical sessions consists of a set of example multi-omics analysis workflows. It is assumed that you have already installed the required software. Do not hesitate to ask support from the course assistants. 2.1 Day 1 Lectures Metagenomics - Kata Metabolomics - Pande Multiomics - Leo Practical Data import and exploration Beta diversity 2.2 Day 2 Lectures ML - Matti Gergely individual-based modeling Data integration - Leo Practical ML Unsupervised learning: UMAP clustering Supervised learning: Random forest Model selection and evaluation "],["getting-started.html", "Chapter 3 Getting started 3.1 Checklist (before the workshop) 3.2 Support and resources 3.3 Installing and loading the required R packages", " Chapter 3 Getting started 3.1 Checklist (before the workshop) Install the following software in advance in order to avoid unnecessary delays and leaving more time for the workshop contents. R (version &gt;4.1.0) RStudio; choose “Rstudio Desktop” to download the latest version. Optional but preferred. For further details, check the Rstudio home page. Install and load the required R packages 3.2 Support and resources For online support on installation and other matters, you can join us at: Users: miaverse Gitter channel Developers: Bioconductor Slack #microbiomeexperiment channel (ask for an invitation) 3.3 Installing and loading the required R packages This section shows how to install and load all required packages into the R session. Only uninstalled packages are installed. # List of packages that we need from cran and bioc cran_pkg &lt;- c(&quot;BiocManager&quot;, &quot;bookdown&quot;, &quot;dplyr&quot;, &quot;ecodist&quot;, &quot;ggplot2&quot;, &quot;gridExtra&quot;, &quot;kableExtra&quot;, &quot;knitr&quot;, &quot;scales&quot;, &quot;vegan&quot;, &quot;caret&quot;, &quot;ranger&quot;, &quot;stringr&quot;, &quot;pheatmap&quot;) bioc_pkg &lt;- c(&quot;ANCOMBC&quot;, &quot;ape&quot;, &quot;DESeq2&quot;, &quot;DirichletMultinomial&quot;, &quot;mia&quot;, &quot;miaViz&quot;, &quot;microbiomeDataSets&quot;) # Gets those packages that are already installed cran_pkg_already_installed &lt;- cran_pkg[ cran_pkg %in% installed.packages() ] bioc_pkg_already_installed &lt;- bioc_pkg[ bioc_pkg %in% installed.packages() ] # Gets those packages that need to be installed cran_pkg_to_be_installed &lt;- setdiff(cran_pkg, cran_pkg_already_installed) bioc_pkg_to_be_installed &lt;- setdiff(bioc_pkg, bioc_pkg_already_installed) # If there are packages that need to be installed, installs them from CRAN if( length(cran_pkg_to_be_installed) ) { install.packages(cran_pkg_to_be_installed) } # If there are packages that need to be installed, installs them from Bioconductor if( length(bioc_pkg_to_be_installed) ) { BiocManager::install(bioc_pkg_to_be_installed, ask = F) } Now all required packages are installed, so let’s load them into the session. Some function names occur in multiple packages. That is why miaverse’s packages mia and miaViz are prioritized. Packages that are loaded first have higher priority. # Reorders bioc packages, so that mia and miaViz are first bioc_pkg &lt;- c(bioc_pkg[ bioc_pkg %in% c(&quot;mia&quot;, &quot;miaViz&quot;) ], bioc_pkg[ !bioc_pkg %in% c(&quot;mia&quot;, &quot;miaViz&quot;) ] ) # Loading all packages into session. Returns true if package was successfully loaded. loaded &lt;- sapply(c(bioc_pkg, cran_pkg), require, character.only = TRUE) as.data.frame(loaded) ## loaded ## mia TRUE ## miaViz TRUE ## ANCOMBC TRUE ## ape TRUE ## DESeq2 TRUE ## DirichletMultinomial TRUE ## microbiomeDataSets TRUE ## BiocManager TRUE ## bookdown TRUE ## dplyr TRUE ## ecodist TRUE ## ggplot2 TRUE ## gridExtra TRUE ## kableExtra TRUE ## knitr TRUE ## scales TRUE ## vegan TRUE ## caret TRUE ## ranger TRUE ## stringr TRUE ## pheatmap TRUE "],["data.html", "Chapter 4 Data 4.1 Data structure 4.2 Example data 4.3 Importing data in R", " Chapter 4 Data This section demonstrates how to import data in R. 4.1 Data structure Such analysis using the miaverse framework, are based upon core data structures including SingleCellExperiment (SCE), SummarizedExperiment (SE), TreeSummarizedExperiment (TreeSE) and MultiAssayExperiment (MAE) (resources). Multi-assay data can be stored in altExp slot of TreeSE or MAE data container. Different data sets are first imported into SE or TreeSE data container similarly to the case when only one data set is present. After that different data sets are combined into the same data container. Result is one TreeSE object with alternative experiment in altExp slot, or MAE object with multiple experiment in its experiment slot. 4.2 Example data As an example data, we use data from following publication: Hintikka L et al. (2021) Xylo-oligosaccharides in prevention of hepatic steatosis and adipose tissue inflammation: associating taxonomic and metabolomic patterns in fecal microbiotas with biclustering. This example data can be loaded from microbiomeDataSets. The data is already in MAE format. It includes three different experiments: microbial abundance data, metabolite concentrations, and data about different biomarkers. 4.3 Importing data in R library(stringr) # Load the data mae &lt;- microbiomeDataSets::HintikkaXOData() # Drop off those bacteria that do not include information in Phylum or lower levels mae[[1]] &lt;- mae[[1]][!is.na(rowData(mae[[1]])$Phylum), ] # Clean taxonomy data, so that names do not include addtional characters rowData(mae[[1]]) &lt;- DataFrame(apply(rowData(mae[[1]]), 2, str_remove, pattern = &quot;._[0-9]__&quot;)) mae ## A MultiAssayExperiment object of 3 listed ## experiments with user-defined names and respective classes. ## Containing an ExperimentList class object of length 3: ## [1] microbiota: SummarizedExperiment with 12613 rows and 40 columns ## [2] metabolites: SummarizedExperiment with 38 rows and 40 columns ## [3] biomarkers: SummarizedExperiment with 39 rows and 40 columns ## Functionality: ## experiments() - obtain the ExperimentList instance ## colData() - the primary/phenotype DataFrame ## sampleMap() - the sample coordination DataFrame ## `$`, `[`, `[[` - extract colData columns, subset, or experiment ## *Format() - convert into a long or wide DataFrame ## assays() - convert ExperimentList to a SimpleList of matrices ## exportClass() - save data to flat files "],["microbiome-data-exploration.html", "Chapter 5 Microbiome data exploration 5.1 Data structure 5.2 Visualization", " Chapter 5 Microbiome data exploration Now we have loaded the data set into R. Next, let us walk through some basic operations for data exploration to confirm that the data has all the necessary components. 5.1 Data structure Let us now investigate how taxonomic profiling data is organized in R. Dimensionality tells us how many taxa and samples the data contains. As we can see, there are 12613 taxa and 40 samples. # mae[[1]]: indexing/retrieving the taxonomic data experiment dim(mae[[1]]) ## [1] 12613 40 The rowData slot contains a taxonomic table. This includes taxonomic information for each of the 12613 entries. With the head() command, we can print just the beginning of the table. The rowData seems to contain information from 7 different taxonomy classes. knitr::kable(head(rowData(mae[[1]]))) %&gt;% kableExtra::kable_styling(&quot;striped&quot;, latex_options=&quot;scale_down&quot;) %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) Phylum Class Order Family Genus Species OTU GAYR01026362.62.2014 Proteobacteria Alphaproteobacteria Rickettsiales Mitochondria Solanum melongena (eggplant) Solanum melongena (eggplant) GAYR01026362.62.2014 CVJT01000011.50.2173 Firmicutes Bacilli Bacillales Staphylococcaceae Staphylococcus Staphylococcus aureus CVJT01000011.50.2173 KF625183.1.1786 Proteobacteria Gammaproteobacteria Enterobacteriales Enterobacteriaceae Klebsiella Klebsiella oxytoca KF625183.1.1786 AYSG01000002.292.2076 Firmicutes Bacilli Lactobacillales Streptococcaceae Streptococcus Streptococcus thermophilus TH1435 AYSG01000002.292.2076 CCPS01000022.154.1916 Proteobacteria Gammaproteobacteria Enterobacteriales Enterobacteriaceae Escherichia-Shigella Escherichia coli CCPS01000022.154.1916 KJ923794.1.1762 Firmicutes Bacilli Bacillales Staphylococcaceae Staphylococcus Staphylococcus aureus KJ923794.1.1762 The colData slot contains sample metadata. It contains information for all 40 samples. However, here only the 6 first samples are shown as we use the head() command. There are 6 columns, that contain information, e.g., about patients’ status, and cohort. # For simplicity, classify all high-fat diets as high-fat, and all the low-fat # diets as low-fat diets colData(mae)$Diet &lt;- ifelse(colData(mae)$Diet == &quot;High-fat&quot; | colData(mae)$Diet == &quot;High-fat + XOS&quot;, &quot;High-fat&quot;, &quot;Low-fat&quot;) knitr::kable(head(colData(mae))) %&gt;% kableExtra::kable_styling(&quot;striped&quot;, latex_options=&quot;scale_down&quot;) %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) Sample Rat Site Diet Fat XOS C1 C1 1 Cecum High-fat High 0 C2 C2 2 Cecum High-fat High 0 C3 C3 3 Cecum High-fat High 0 C4 C4 4 Cecum High-fat High 0 C5 C5 5 Cecum High-fat High 0 C6 C6 6 Cecum High-fat High 0 From here, we can draw summaries of the sample (column) data, for instance to see what is the diet distribution. The command colData(mae)$Diet fetches the data from the column, and table() creates a table that shows how many times each class is present, and sort() sorts the table to ascending order. There are 20 samples from mice having High-fat, and 20 Low-fat. sort(table(colData(mae)$Diet)) ## ## High-fat Low-fat ## 20 20 5.1.1 Transformations Microbial abundances are typically ‘compositional’ (relative) in the current microbiome profiling data sets. This is due to technical aspects of the data generation process (see e.g. Gloor et al., 2017). The next example calculates relative abundances as these are usually easier to interpret than plain counts. For some statistical models we need to transform the data into other formats as explained in above link (and as we will see later). # Calculates relative abundances, and stores the table to assays mae[[1]] &lt;- transformCounts(mae[[1]], method = &quot;relabundance&quot;) A variety of standard transformations for microbiome data are available through mia R package. 5.1.2 Aggregation Microbial species can be called at multiple taxonomic resolutions. We can easily agglomerate the data based on taxonomic ranks. Here, we agglomerate the data at Phylum level. se_phylum &lt;- agglomerateByRank(mae[[1]], rank = &quot;Phylum&quot;) # Show dimensionality dim(se_phylum) ## [1] 13 40 Now there are 13 taxa and 40 samples, meaning that there are 13 different Phylum level taxonomic groups. Looking at the rowData after agglomeration shows all Firmicutes are combined together, and all lower rank information is lost. From the assay we can see that all abundances of taxa that belong to Firmicutes are summed up. knitr::kable(head(rowData(se_phylum))) %&gt;% kableExtra::kable_styling(&quot;striped&quot;, latex_options=&quot;scale_down&quot;) %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) Phylum Class Order Family Genus Species OTU Proteobacteria Proteobacteria NA NA NA NA NA GAYR01026362.62.2014 Firmicutes Firmicutes NA NA NA NA NA CVJT01000011.50.2173 Cyanobacteria Cyanobacteria NA NA NA NA NA GEMN01027092.33.1623 Tenericutes Tenericutes NA NA NA NA NA AM277369.1.1548 Deferribacteres Deferribacteres NA NA NA NA NA AYGZ01000001.327.1863 Actinobacteria Actinobacteria NA NA NA NA NA JGZF01000005.1.1534 If you are sharp, you have by now noticed that all the aggregated values in the above example are NA’s (missing data). This is because the agglomeration is missing abundances for certain taxa, and in that case the sum is not defined by default (na.rm = FALSE). We can ignore the missing values in summing up the data by setting na.rm = TRUE; then the taxa that do not have information in specified level will be removed. Those taxa that do not have information in specified level are agglomerated at lowest possible level that is left after agglomeration. temp &lt;- rowData(agglomerateByRank(mae[[1]], rank = &quot;Genus&quot;)) # Prints those taxa that do not have information at the Genus level (NA) knitr::kable(head(temp[which(is.na(temp$Genus)),])) %&gt;% kableExtra::kable_styling(&quot;striped&quot;, latex_options=&quot;scale_down&quot;) %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) Phylum Class Order Family Genus Species OTU Family:uncultured Proteobacteria Alphaproteobacteria Rhodospirillales uncultured NA NA JRJTB:01000:00983 Family:Ruminococcaceae Firmicutes Clostridia Clostridiales Ruminococcaceae NA NA JRJTB:00751:00256 Order:Clostridiales Firmicutes Clostridia Clostridiales NA NA NA JRJTB:03059:01977 Family:Lachnospiraceae Firmicutes Clostridia Clostridiales Lachnospiraceae NA NA JRJTB:00738:02832 Family:Peptostreptococcaceae Firmicutes Clostridia Clostridiales Peptostreptococcaceae NA NA JRJTB:01731:00274 Family:Pasteurellaceae Proteobacteria Gammaproteobacteria Pasteurellales Pasteurellaceae NA NA JRJTB:01960:01703 Here agglomeration is done similarly, but na.rm = TRUE temp2 &lt;- rowData(agglomerateByRank(mae[[1]], rank = &quot;Genus&quot;, na.rm = TRUE)) print(paste0(&quot;Agglomeration with na.rm = FALSE: &quot;, dim(temp)[1], &quot; taxa.&quot;)) ## [1] &quot;Agglomeration with na.rm = FALSE: 277 taxa.&quot; print(paste0(&quot;Agglomeration with na.rm = TRUE: &quot;, dim(temp2)[1], &quot; taxa.&quot;)) ## [1] &quot;Agglomeration with na.rm = TRUE: 262 taxa.&quot; The mia package contains further examples on various data agglomeration and splitting options. 5.2 Visualization The miaViz package facilitates data visualization. Let us plot the Phylum level abundances. # Here we specify &quot;relabundance&quot; to be abundance table that we use for plotting. # Note that we can use agglomerated or non-agglomerated mae[[1]] as an input, because # the function agglomeration is built-in option. # Legend does not fit into picture, so its height is reduced. plot_abundance &lt;- plotAbundance(mae[[1]], abund_values=&quot;relabundance&quot;, rank = &quot;Phylum&quot;) + theme(legend.key.height = unit(0.5, &quot;cm&quot;)) + scale_y_continuous(label = scales::percent) plot_abundance Density plot shows the overall abundance distribution for a given taxonomic group. Let us check the relative abundance of Firmicutes across the sample collection. The density plot is a smoothened version of a standard histogram. The plot shows peak abundances around 30 %. # Subset data by taking only Firmicutes se_firmicutes &lt;- se_phylum[&quot;Firmicutes&quot;] # Gets the abundance table abundance_firmicutes &lt;- assay(se_firmicutes, &quot;relabundance&quot;) # Creates a data frame object, where first column includes abundances firmicutes_abund_df &lt;- as.data.frame(t(abundance_firmicutes)) # Rename the first and only column colnames(firmicutes_abund_df) &lt;- &quot;abund&quot; # Creates a plot. Parameters inside feom_density are optional. With # geom_density(bw=1000), it is possible to adjust bandwidth. firmicutes_abund_plot &lt;- ggplot(firmicutes_abund_df, aes(x = abund)) + geom_density(color=&quot;darkred&quot;, fill=&quot;lightblue&quot;) + labs(x = &quot;Relative abundance&quot;, title = &quot;Firmicutes&quot;) + theme_classic() + # Changes the background scale_x_continuous(label = scales::percent) firmicutes_abund_plot For more visualization options and examples, see the miaViz vignette. "],["beta-diversity.html", "Chapter 6 Beta diversity 6.1 Examples of PCoA with different settings 6.2 Highlighting external variables 6.3 Estimating associations with an external variable 6.4 Community typing", " Chapter 6 Beta diversity Beta diversity is another name for sample dissimilarity. It quantifies differences in the overall taxonomic composition between two samples. Common indices include Bray-Curtis, Unifrac, Jaccard index, and the Aitchison distance. Each of these (dis)similarity measures emphasizes different aspects. For example, UniFrac incorporates phylogenetic information, and Jaccard index ignores exact abundances and considers only presence/absence values. For more background information and examples, you can check the dedicated section in online book. 6.1 Examples of PCoA with different settings Beta diversity estimation generates a (dis)similarity matrix that contains for each sample (rows) the dissimilarity to any other sample (columns). This complex set of pairwise relations can be visualized in informative ways, and even coupled with other explanatory variables. As a first step, we compress the information to a lower dimensionality, or fewer principal components, and then visualize sample similarity based on that using ordination techniques, such as Principal Coordinate Analysis (PCoA). PCoA is a non-linear dimension reduction technique, and with Euclidean distances it is is identical to the linear PCA (except for potential scaling). We typically retain just the two (or three) most informative top components, and ignore the other information. Each sample has a score on each of these components, and each component measures the variation across a set of correlated taxa. The top components are then easily visualized on a two (or three) dimensional display. Let us next look at some concrete examples. 6.1.1 PCoA for ASV-level data with Bray-Curtis Let us start with PCoA based on a Bray-Curtis dissimilarity matrix calculated at Genus level abundances. # Pick the relative abundance table rel_abund_assay &lt;- assays(mae[[1]])$relabundance # Calculates Bray-Curtis distances between samples. Because taxa is in # columns, it is used to compare different samples. We transpose the # assay to get taxa to columns bray_curtis_dist &lt;- vegan::vegdist(t(rel_abund_assay), method = &quot;bray&quot;) # PCoA bray_curtis_pcoa &lt;- ecodist::pco(bray_curtis_dist) # All components could be found here: # bray_curtis_pcoa$vectors # But we only need the first two to demonstrate what we can do: bray_curtis_pcoa_df &lt;- data.frame(pcoa1 = bray_curtis_pcoa$vectors[,1], pcoa2 = bray_curtis_pcoa$vectors[,2]) # Create a plot bray_curtis_plot &lt;- ggplot(data = bray_curtis_pcoa_df, aes(x=pcoa1, y=pcoa2)) + geom_point() + labs(x = &quot;PC1&quot;, y = &quot;PC2&quot;, title = &quot;Bray-Curtis PCoA&quot;) + theme(title = element_text(size = 10)) # makes titles smaller bray_curtis_plot 6.1.2 PCoA for ASV-level data with Aitchison distance Now the same using Aitchison distance. This metric corresponds to Euclidean distances between CLR transformed sample abundance vectors. # Does clr transformation. Pseudocount is added, because data contains zeros. mae[[1]] &lt;- transformCounts(mae[[1]], method = &quot;clr&quot;, pseudocount = 1) # Gets clr table clr_assay &lt;- assays(mae[[1]])$clr # Transposes it to get taxa to columns clr_assay &lt;- t(clr_assay) # Calculates Euclidean distances between samples. Because taxa is in columns, # it is used to compare different samples. euclidean_dist &lt;- vegan::vegdist(clr_assay, method = &quot;euclidean&quot;) # Does principal coordinate analysis euclidean_pcoa &lt;- ecodist::pco(euclidean_dist) # Creates a data frame from principal coordinates euclidean_pcoa_df &lt;- data.frame(pcoa1 = euclidean_pcoa$vectors[,1], pcoa2 = euclidean_pcoa$vectors[,2]) # Creates the plot euclidean_plot &lt;- ggplot(data = euclidean_pcoa_df, aes(x=pcoa1, y=pcoa2)) + geom_point() + labs(x = &quot;PC1&quot;, y = &quot;PC2&quot;, title = &quot;Euclidean PCoA with CLR transformation&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_plot 6.1.3 PCoA aggregated to Phylum level We use again the Aitchison distances in this example but this time applied to the phylum level. # Does clr transformation. Psuedocount is added, because data contains zeros. se_phylum &lt;- transformCounts(se_phylum, method = &quot;clr&quot;, pseudocount = 1) # Gets clr table clr_phylum_assay &lt;- assays(se_phylum)$clr # Transposes it to get taxa to columns clr_phylum_assay &lt;- t(clr_phylum_assay) # Calculates Euclidean distances between samples. Because taxa is in columns, # it is used to compare different samples. euclidean_phylum_dist &lt;- vegan::vegdist(clr_assay, method = &quot;euclidean&quot;) # Does principal coordinate analysis euclidean_phylum_pcoa &lt;- ecodist::pco(euclidean_phylum_dist) # Creates a data frame from principal coordinates euclidean_phylum_pcoa_df &lt;- data.frame( pcoa1 = euclidean_phylum_pcoa$vectors[,1], pcoa2 = euclidean_phylum_pcoa$vectors[,2]) # Creates a plot euclidean_phylum_plot &lt;- ggplot(data = euclidean_phylum_pcoa_df, aes(x=pcoa1, y=pcoa2)) + geom_point() + labs(x = &quot;PC1&quot;, y = &quot;PC2&quot;, title = &quot;Aitchison distances at Phylum level&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_phylum_plot 6.2 Highlighting external variables We can map other variables on the same plot for example by coloring the points accordingly. The following is an example with a discrete grouping variable (Diet) shown with colors: # Adds the variable we later use for coloring to the data frame euclidean_diet_pcoa_df &lt;- cbind(euclidean_pcoa_df, Diet = colData(mae)$Diet) # Creates a plot euclidean_diet_plot &lt;- ggplot(data = euclidean_diet_pcoa_df, aes(x=pcoa1, y=pcoa2, color = Diet)) + geom_point() + labs(x = &quot;PC1&quot;, y = &quot;PC2&quot;, title = &quot;PCoA with Aitchison distances&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_diet_plot PCoA plot in some cases could also be overlayed with a continuous variable. (see example) 6.3 Estimating associations with an external variable Next to visualizing whether any variable is associated with differences between samples, we can also quantify the strength of the association between community composition (beta diversity) and external factors. The standard way to do this is to perform a so-called permutational multivariate analysis of variance (PERMANOVA). This method takes as input the abundance table, which measure of distance you want to base the test on and a formula that tells the model how you think the variables are associated with each other. # First we get the relative abundance table rel_abund_assay &lt;- assays(mae[[1]])$relabundance # again transpose it to get taxa to columns rel_abund_assay &lt;- t(rel_abund_assay) # then we can perform the method permanova_diet &lt;- vegan::adonis(rel_abund_assay ~ Diet, data = colData(mae), permutations = 99) # we can obtain a the p value for our predictor: print(paste0(&quot;The test result p-value: &quot;, as.data.frame(permanova_diet$aov.tab)[&quot;Diet&quot;, &quot;Pr(&gt;F)&quot;])) ## [1] &quot;The test result p-value: 0.01&quot; The diet variable is significantly associated with microbiota composition (p-value is less than 0.05). We can visualize those taxa whose abundances drive the differences between diets. We first need to extract the model coefficients of taxa: # Gets the coefficients coef &lt;- coefficients(permanova_diet)[&quot;Diet1&quot;,] # Gets the highest coefficients top.coef &lt;- sort(head(coef[rev(order(abs(coef)))],20)) # Plots the coefficients top_taxa_coeffient_plot &lt;- ggplot(data.frame(x = top.coef, y = factor(names(top.coef), unique(names(top.coef)))), aes(x = x, y = y)) + geom_bar(stat=&quot;identity&quot;) + labs(x=&quot;&quot;, y=&quot;&quot;, title=&quot;Top Taxa&quot;) + theme_bw() top_taxa_coeffient_plot The above plot shows taxa as code names, and it is hard to tell which bacterial groups they represent. However, it is easy to add human readable names. We can fetch those from our rowData. Here we use Genus level names: # Gets corresponding Genus level names and stores them to top.coef names &lt;- rowData(mae[[1]])[names(top.coef), ][,&quot;Genus&quot;] # Adds new labels to the plot top_taxa_coeffient_plot &lt;- top_taxa_coeffient_plot + scale_y_discrete(labels = names) # Adds new labels top_taxa_coeffient_plot The same test can be conducted using the oridination from PCoA as follows: bray_curtis_pcoa_df$Diet &lt;- colData(mae)$Diet p_values &lt;- list() for(pc in c(&quot;pcoa1&quot;, &quot;pcoa2&quot;)){ # Creates a formula from objects formula &lt;- as.formula(paste0(pc, &quot; ~ &quot;, &quot;Diet&quot;)) # Does the permanova analysis p_values[[pc]] &lt;- vegan::adonis(formula, data = bray_curtis_pcoa_df, permutations = 9999, method = &quot;euclidean&quot; )$aov.tab[&quot;Diet&quot;, &quot;Pr(&gt;F)&quot;] } # Creates a plot plot &lt;- ggplot(data = bray_curtis_pcoa_df, aes_string(x = &quot;pcoa1&quot;, y = &quot;pcoa2&quot;, color = &quot;Diet&quot;)) + geom_point(size = 3) + labs(title = paste0(&quot;PCoA beta diversity ordination for microbiome samples&quot;), x = paste0(&quot;PC1 (p = &quot;, p_values[[&quot;pcoa1&quot;]], &quot;)&quot;), y = paste0(&quot;PC2 (p = &quot;, p_values[[&quot;pcoa2&quot;]], &quot;)&quot;)) + theme_bw(12) plot There are many alternative and complementary methods for analysing community composition. For more examples, see a dedicated section on beta diversity in the online book. 6.4 Community typing A dedicated section presenting examples on community typing is in the online book. "],["unsupervised-learning.html", "Chapter 7 Unsupervised learning 7.1 Biclustering", " Chapter 7 Unsupervised learning 7.1 Biclustering Exploring metabolomic data: library(ggplot2) # Threshold: metabolites whose (cv &gt; +threshold or cv &lt; -threshold), will be included cv_threshold &lt;- 0.5 metabolite_trans &lt;- &quot;nmr&quot; # Get the data metabolite_tse &lt;- mae[[2]] # Calculate coeffieicnt of variation of individual metabolites df &lt;- data.frame(cv = apply(assay(metabolite_tse, metabolite_trans), 1, function(x){sd(x)/mean(x)})) # Plot them as a histogram, and show a line that is used as a threshold plot &lt;- ggplot(df, aes(x = cv)) + geom_histogram(bins = 50, color=&quot;darkred&quot;, fill=&quot;lightblue&quot;) + labs(x = &quot;CV&quot;, y = &quot;metabolite frequency&quot;, title = &quot;Distribution of coefficient of variation of log10 concentration of metabolites&quot;) + geom_vline(xintercept = cv_threshold, color = &quot;red&quot;) + geom_text(aes(cv_threshold, 6, label = paste0(&quot;CV threshold (&quot;, cv_threshold, &quot;)&quot;), vjust = 2, angle=90)) + geom_vline(xintercept = -cv_threshold, color = &quot;red&quot;) + geom_text(aes(-cv_threshold, 6, label = paste0(&quot;CV threshold (&quot;, -cv_threshold, &quot;)&quot;), vjust = -1, angle=90)) plot Subsetting metabolomic data: # Get those metabolites that are over threshold metabolites_over_th &lt;- rownames(df[df$cv &gt; cv_threshold | df$cv &lt; -cv_threshold, , drop = FALSE]) # Ignore those metabolites that do not have name / are NA metabolites_over_th &lt;- metabolites_over_th[!str_detect(metabolites_over_th, &quot;NA&quot;)] Preprocessing microbiome and metabolomic data: rank &lt;- &quot;Genus&quot; prevalence &lt;- 0.2 detection &lt;- 0.001 taxa_trans &lt;- &quot;rclr&quot; # Get bacterial data taxa_tse &lt;- mae[[1]] # Agglomerate at Genus level taxa_tse &lt;- agglomerateByRank(taxa_tse, rank = rank) # Do CLR transformation taxa_tse &lt;- transformSamples(taxa_tse, method = &quot;rclr&quot;, pseudocount = 1) # Subset metabolite data metabolite_tse &lt;- metabolite_tse[metabolites_over_th, ] # Subset bacterial data by its prevalence. Bacteria whose prevalences are over # threshold are included taxa_tse &lt;- subsetByPrevalentTaxa(taxa_tse, prevalence = prevalence, detection = detection) # Remove uncultured and ambiguous(as it&#39;s hard to interpret their results) taxa_tse &lt;- taxa_tse[-grep(&quot;uncultured|Ambiguous_taxa&quot;, names(taxa_tse)),] Cross-correlation of both data and visualization: library(pheatmap) # Define data sets to cross-correlate x &lt;- t(assay(taxa_tse, taxa_trans)) y &lt;- t(assay(metabolite_tse, &quot;nmr&quot;)) # If there are duplicated taxa names, makes them unique colnames(x) &lt;- str_remove(colnames(x), paste0(rank, &quot;:&quot;)) colnames(x) &lt;- make.unique(colnames(x)) # Cross correlate data sets correlations &lt;- microbiome::associate(x, y, method = &quot;spearman&quot;, mode = &quot;matrix&quot;) # For plotting purpose, convert p-values, under 0.05 are marked with &quot;X&quot; p_threshold &lt;- 0.01 p_values &lt;- ifelse(correlations$p.adj&lt;p_threshold, &quot;X&quot;, &quot;&quot;) # Scale colors breaks &lt;- seq(-ceiling(max(abs(correlations$cor))), ceiling(max(abs(correlations$cor))), length.out = ifelse( max(abs(correlations$cor))&gt;5, 2*ceiling(max(abs(correlations$cor))), 10 ) ) colors &lt;- colorRampPalette(c(&quot;darkblue&quot;, &quot;blue&quot;, &quot;white&quot;, &quot;red&quot;, &quot;darkred&quot;))(length(breaks)-1) # Create a heatmap pheatmap(correlations$cor, display_numbers = p_values, main = paste0(&quot;Correlations between bacteria and metabolites (statistically significant associations (p &lt; 0.05) marked with X)&quot;), fontsize = 10, breaks = breaks, color = colors, fontsize_number = 20) "],["supervised-learning.html", "Chapter 8 Supervised learning", " Chapter 8 Supervised learning Coming up… "],["model-selection-and-evaluation.html", "Chapter 9 Model selection and evaluation", " Chapter 9 Model selection and evaluation Coming up… "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
